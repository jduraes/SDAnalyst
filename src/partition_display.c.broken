#include "partition_display.h"
#include "sd_card.h"
#include <stdio.h>
#include <string.h>

// Enhanced partition information functions
int partition_display_enhance_partition_info(enhanced_partition_info_t* enhanced,
                                            const partition_info_t* basic) {
    if (!enhanced || !basic) return -1;
    
    // Copy basic information
    enhanced->type = basic->type;
    enhanced->start_lba = basic->start_lba;
    enhanced->size_sectors = basic->size_sectors;
    enhanced->bootable = basic->bootable;
    enhanced->status = basic->bootable ? 0x80 : 0x00;
    enhanced->active = basic->bootable;
    
    strncpy(enhanced->name, basic->name, sizeof(enhanced->name) - 1);
    enhanced->name[sizeof(enhanced->name) - 1] = '\0';
    
    strncpy(enhanced->filesystem, basic->filesystem, sizeof(enhanced->filesystem) - 1);
    enhanced->filesystem[sizeof(enhanced->filesystem) - 1] = '\0';
    
    // Get type description
    partition_display_get_type_description(enhanced->type, enhanced->type_description, 
                                          sizeof(enhanced->type_description));
    
    // Get status description
    partition_display_get_status_description(enhanced->status, enhanced->bootable,
                                            enhanced->status_description,
                                            sizeof(enhanced->status_description));
    
    // Try to get volume label from filesystem
    if (partition_display_get_volume_label(enhanced->start_lba, enhanced->filesystem,
                                         enhanced->volume_label, 
                                         sizeof(enhanced->volume_label)) != 0) {
        enhanced->volume_label[0] = '\0';
    }
    
    return 0;
}

void partition_display_get_type_description(uint8_t type, char* description, size_t size) {
    switch (type) {
        case 0x00: strncpy(description, "Empty", size - 1); break;
        case 0x01: strncpy(description, "FAT12", size - 1); break;
        case 0x04: strncpy(description, "FAT16 <32MB", size - 1); break;
        case 0x06: strncpy(description, "FAT16", size - 1); break;
        case 0x07: strncpy(description, "NTFS/exFAT", size - 1); break;
        case 0x0B: strncpy(description, "FAT32", size - 1); break;
        case 0x0C: strncpy(description, "FAT32 LBA", size - 1); break;
        case 0x0E: strncpy(description, "FAT16 LBA", size - 1); break;
        case 0x82: strncpy(description, "Linux Swap", size - 1); break;
        case 0x83: strncpy(description, "Linux", size - 1); break;
        case 0x8E: strncpy(description, "Linux LVM", size - 1); break;
        case 0xEE: strncpy(description, "GPT Protective", size - 1); break;
        case 0xEF: strncpy(description, "EFI System", size - 1); break;
        default: 
            snprintf(description, size, "Unknown (0x%02X)", type);
            break;
    }
    description[size - 1] = '\0';
}

void partition_display_get_status_description(uint8_t status, bool bootable, 
                                             char* description, size_t size) {
    if (bootable || status == 0x80) {
        strncpy(description, "Bootable", size - 1);
    } else if (status == 0x00) {
        strncpy(description, "Data", size - 1);
    } else {
        snprintf(description, size, "Unknown (0x%02X)", status);
    }
    description[size - 1] = '\0';
}

int partition_display_get_volume_label(uint32_t start_lba, const char* filesystem,
                                     char* label, size_t label_size) {
    uint8_t boot_sector[512];
    
    if (sd_read_block(start_lba, boot_sector) != 0) {
        return -1;
    }
    
    // Initialize label as empty
    label[0] = '\0';
    
    // Check for FAT filesystems
    if (strncmp(filesystem, "FAT", 3) == 0) {
        // For FAT12/16, volume label is at offset 43
        // For FAT32, volume label is at offset 71
        if (strcmp(filesystem, "FAT32") == 0) {
            // FAT32 volume label
            if (boot_sector[71] != 0x00 && boot_sector[71] != 0x20) {
                strncpy(label, (char*)&boot_sector[71], 11);
                label[11] = '\0';
                // Trim trailing spaces
                for (int i = 10; i >= 0 && label[i] == ' '; i--) {
                    label[i] = '\0';
                }
            }
        } else {
            // FAT12/16 volume label
            if (boot_sector[43] != 0x00 && boot_sector[43] != 0x20) {
                strncpy(label, (char*)&boot_sector[43], 11);
                label[11] = '\0';
                // Trim trailing spaces
                for (int i = 10; i >= 0 && label[i] == ' '; i--) {
                    label[i] = '\0';
                }
            }
        }
    }
    
    return 0;
}

// Utility functions
void partition_display_format_size(uint64_t size_bytes, char* output, size_t output_size) {
    if (size_bytes >= (1024ULL * 1024 * 1024 * 1024)) {
        snprintf(output, output_size, "%.1f TB", size_bytes / (1024.0 * 1024 * 1024 * 1024));
    } else if (size_bytes >= (1024ULL * 1024 * 1024)) {
        snprintf(output, output_size, "%.1f GB", size_bytes / (1024.0 * 1024 * 1024));
    } else if (size_bytes >= (1024ULL * 1024)) {
        snprintf(output, output_size, "%.1f MB", size_bytes / (1024.0 * 1024));
    } else if (size_bytes >= 1024) {
        snprintf(output, output_size, "%.1f KB", size_bytes / 1024.0);
    } else {
        snprintf(output, output_size, "%llu B", size_bytes);
    }
}

void partition_display_format_size_detailed(uint64_t size_bytes, char* output, size_t output_size) {
    uint64_t size_sectors = size_bytes / 512;
    
    if (size_bytes >= (1024ULL * 1024 * 1024 * 1024)) {
        snprintf(output, output_size, "%.2f TB (%llu sectors)", 
                size_bytes / (1024.0 * 1024 * 1024 * 1024), size_sectors);
    } else if (size_bytes >= (1024ULL * 1024 * 1024)) {
        snprintf(output, output_size, "%.1f GB (%llu sectors)", 
                size_bytes / (1024.0 * 1024 * 1024), size_sectors);
    } else if (size_bytes >= (1024ULL * 1024)) {
        snprintf(output, output_size, "%.1f MB (%llu sectors)", 
                size_bytes / (1024.0 * 1024), size_sectors);
    } else {
        snprintf(output, output_size, "%.1f KB (%llu sectors)", 
                size_bytes / 1024.0, size_sectors);
    }
}

const char* partition_display_get_display_name(const enhanced_partition_info_t* partition) {
    // Priority: volume_label > name > generic fallback
    if (partition->volume_label[0] != '\0') {
        return partition->volume_label;
    } else if (partition->name[0] != '\0' && strcmp(partition->name, "(unnamed)") != 0) {
        return partition->name;
    } else {
        return "(no label)";
    }
}

// Table printing functions
void partition_display_print_table_header(const table_format_options_t* options) {
    printf("\n+----+------------------+----------+---------+-----------+\n");
    printf("| #  | Name/Label       | Type     | Size      | Status/Type |\n");
    printf("+----+------------------+----------+---------+-----------+\n");
}

void partition_display_print_partition_row(int partition_num, 
                                          const enhanced_partition_info_t* partition,
                                          const table_format_options_t* options) {
    char size_str[32];
    uint64_t size_bytes = (uint64_t)partition->size_sectors * 512;
    partition_display_format_size(size_bytes, size_str, sizeof(size_str));
    
    const char* display_name = partition_display_get_display_name(partition);
    
    printf("| %-2d | %-16.16s | %-8s | %7s | %-11s |\n",
           partition_num,
           display_name,
           partition->filesystem,
           size_str,
           partition->status_description);
}

void partition_display_print_table_footer(void) {
    printf("+----+------------------+----------+---------+-----------+\n");
}

void partition_display_print_unified_table(const enhanced_partition_info_t* partitions,
                                          int partition_count,
                                          const char* table_type) {
    if (partition_count <= 0) {
        printf("No partitions found.\n");
        return;
    }
    
    table_format_options_t options = {
        .show_status = true,
        .show_type_hex = false,
        .show_volume_labels = true,
        .use_long_names = true,
        .name_width = 16,
        .size_width = 9
    };
    
    partition_display_print_table_header(&options);
    
    for (int i = 0; i < partition_count; i++) {
        partition_display_print_partition_row(i + 1, &partitions[i], &options);
    }
    
    partition_display_print_table_footer();
}
